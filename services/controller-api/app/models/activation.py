"""
OpenWhisk Activation Model

Represents execution records for action invocations in Apache OpenWhisk.

An activation is created every time an action is invoked, capturing:
- Timing information (start, end, duration)
- Execution results (success/failure, return value)
- Logs generated during execution
- Metadata (annotations, limits, init time, wait time)
- Causality (parent activations for sequences/compositions)

Activation Record Format:
{
    "activationId": "uuid-string",
    "namespace": "user@email.com",
    "name": "/namespace/package/action",
    "version": "0.0.1",
    "subject": "user@email.com",
    "start": 1234567890123,
    "end": 1234567890456,
    "duration": 333,
    "statusCode": 0,
    "response": {
        "success": true,
        "result": {...}
    },
    "logs": ["timestamp stdout/stderr message"],
    "annotations": {
        "path": "/namespace/package/action",
        "kind": "python:3.13",
        "waitTime": 10,
        "initTime": 100,
        "limits": {"timeout": 60000, "memory": 256}
    },
    "cause": "parent-activation-uuid",
    "publish": false
}

Status Codes:
- 0: Success - action completed successfully
- 1: Application error - error in action code
- 2: Developer error - bad request, invalid parameters
- 3: Internal error - system/platform error

Performance Considerations:
- Primary query pattern: list activations by namespace + time
- Index on (namespace_id, start DESC) for efficient pagination
- Index on activation_id for UUID lookups
- Index on action_name for filtering by action
- Index on cause for tracing sequence executions
"""

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from pydal import DAL


def define_activation_table(db: 'DAL') -> None:
    """
    Define the activation table for OpenWhisk execution records.

    Args:
        db: PyDAL database instance

    Indexes:
        - (namespace_id, start DESC): List activations by time
        - activation_id: Lookup by external UUID
        - action_name: Filter by action
        - cause: Find child activations in sequences
    """
    db.define_table(
        'activation',
        # Primary key (auto-generated by PyDAL)
        db.Field(
            'activation_id',
            'string',
            length=36,
            required=True,
            notnull=True,
            unique=True,
            comment='UUID for external reference'
        ),

        # Namespace reference
        db.Field(
            'namespace_id',
            'reference namespace',
            required=True,
            notnull=True,
            ondelete='CASCADE',
            comment='Namespace owning this activation'
        ),

        # Action identification
        db.Field(
            'action_name',
            'string',
            length=512,
            required=True,
            notnull=True,
            comment='Fully qualified action name: /namespace/package/action'
        ),
        db.Field(
            'action_version',
            'string',
            length=32,
            required=True,
            notnull=True,
            comment='Action semantic version'
        ),
        db.Field(
            'subject',
            'string',
            length=255,
            required=True,
            notnull=True,
            comment='Email of invoking user/service'
        ),

        # Timing information (epoch milliseconds)
        db.Field(
            'start',
            'bigint',
            required=True,
            notnull=True,
            comment='Activation start time (epoch milliseconds)'
        ),
        db.Field(
            'end',
            'bigint',
            required=False,
            comment='Activation end time (epoch milliseconds)'
        ),
        db.Field(
            'duration',
            'integer',
            required=False,
            comment='Execution duration in milliseconds'
        ),

        # Status and response
        db.Field(
            'status_code',
            'integer',
            required=True,
            notnull=True,
            default=0,
            comment='0=success, 1=app error, 2=dev error, 3=internal error'
        ),
        db.Field(
            'response_success',
            'boolean',
            required=True,
            notnull=True,
            default=True,
            comment='Whether action execution succeeded'
        ),
        db.Field(
            'response_result',
            'json',
            required=False,
            comment='Action return value as JSON'
        ),

        # Logs and annotations
        db.Field(
            'logs',
            'json',
            required=True,
            notnull=True,
            default=[],
            comment='Array of log lines with timestamps'
        ),
        db.Field(
            'annotations',
            'json',
            required=True,
            notnull=True,
            default={},
            comment='Metadata: path, kind, waitTime, initTime, limits'
        ),

        # Causality and publishing
        db.Field(
            'cause',
            'string',
            length=36,
            required=False,
            comment='Parent activation_id for sequences/compositions'
        ),
        db.Field(
            'publish',
            'boolean',
            required=True,
            notnull=True,
            default=False,
            comment='Whether activation is published to feed'
        ),

        # Timestamps
        db.Field(
            'created_at',
            'datetime',
            required=True,
            notnull=True,
            default=db.request_now if hasattr(db, 'request_now') else None,
            comment='Record creation timestamp'
        ),

        # Table metadata
        migrate=True,
        fake_migrate=False,
        redefine=False
    )

    # Critical performance indexes
    # Primary query: list activations by namespace + time
    db.executesql(
        'CREATE INDEX IF NOT EXISTS idx_activation_namespace_time '
        'ON activation(namespace_id, start DESC);'
    )

    # Lookup by external UUID
    db.executesql(
        'CREATE INDEX IF NOT EXISTS idx_activation_id '
        'ON activation(activation_id);'
    )

    # Filter by action name
    db.executesql(
        'CREATE INDEX IF NOT EXISTS idx_activation_action '
        'ON activation(action_name);'
    )

    # Trace sequence executions
    db.executesql(
        'CREATE INDEX IF NOT EXISTS idx_activation_cause '
        'ON activation(cause);'
    )
